{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Grom Grom, a .NET graph database object relational mapper. Grom is an easy to use, low config ORM that lets you map your C# classes to nodes and relationships in various graph databases. This project is currently not production ready as it's still in beta. Version 1.0 is expected to release in Q4 2022. Since this project is open source and currently only worked on by the maintainer a 'beta' phase was needed in which a pre-production version is released so bugs can be found and fixed and important missing features can be requested before an actual production ready version is released. Feel free to try it out and if some feature is missing don't hesitate to open an issue! Quick start Connecting Grom to your database Configuring Grom is easy, it only requires a database connection to be given to GromGraph.CreateConnection(...). You don't need to instantiate this class or call it anywhere after running CreateConnection once. Neo4J To configure Grom for Neo4J simply use: GromGraph.CreateConnection(GraphDatabase.Driver(\"bolt://localhost:7687\", AuthTokens.Basic(\"neo4j\", \"test\"))); Any valid instance of Neo4J IDriver can be passed, so you are not restricted to username/password authentication. Mapping a class To map a class as a node you have to do two things: inherit from EntityNode and annotate each property you want to map with NodeProperty. Grom does also require an empty constructor for all nodes. A mapped class can be as simple as: public class Person : EntityNode { [NodeProperty] public string Name { get; set; } [NodeProperty] public int Age { get; set; } } Currently integer, boolean, string, float, long, DateTime and DateOnly are supported. Persisting a node To persist a node simply call Persist() on any of your objects that inherit from EntityNode. var personNode = new Person(\"John\", 25); await personNode.Persist(); Grom is fully asynchronous so make sure you await when required. Updating a node Updating a node is also done by calling Persist(). Grom will figure out if the node is allready created or not. var personNode = new Person(\"John\", 25); await personNode.Persist(); personNode.Age = 30; await personNode.Persist(); Do note that Grom only knows that a node exists if you have called Persist() on it or have retrieved it with Retrieve. It wont check if a node exists with the same properties in the database! Deleting a node A node can be deleted by calling DeleteNode(). await personNode.DeleteNode(); The actual object in your code will still exist but the node and all its relationships to other nodes will be deleted in the database. Retrieving a node Nodes can be retrieved using Retrieve\\ . Nodes can be filtered by simply giving a lambda function that has a single parameter (the root node) and returns a boolean. Grom turns the lambda function into a query for you. var personNode = await Retrieve<Person> .Where(p => p.Name == \"John\") .GetSingle(); Boolean operators such as &&, ||, !, ==, !=, >, <, >= and <= are supported. Properties can be compared to constants, variables, method calls with no parameters and properties or fields in objects. Do note however that Grom can't turn everything a lambda can do into a query. Try to keep the lambda simple. Relationships For now only directed relationships are supported. Release 1.0 will also include support for undirected relationships. To define a relationship between nodes we first need to create a relationship entity. The entity needs to inherit from RelationshipBase and needs an empty constructor. Each property you want to map can be annotated with RelationshipProperty. A relationship entity will look something like this: public class Knows : RelationshipBase { [RelationshipProperty] public int ForYears { get; set; } public Knows() { } public Knows(int forYears) { ForYears = forYears; } } To define a relationship between nodes simply add a new property with type RelationshipCollection. This collection needs two arguments: a relationship type and a target node type. public class Person : EntityNode { [NodeProperty] public string Name { get; set; } [NodeProperty] public int Age { get; set; } public RelationshipCollection<Knows, Person> knownPeople { get; set; } = new(); public Person() { } public Person(string name, int age) { Name = name; Age = age; } } A relationship is added by adding an item to this collection: var person1 = new Person(\"John\", 25); var person2 = new Person(\"Doe\", 26); person1.knownPeople.Add(new Knows(5), person2); await person1.Persist(); Calling Persist() will, in adition to the node, also persist or update any descendant nodes and relationships. Updating works the same way as with nodes, change the property and call Persist() again on any ancestor node. To delete a relationship you can use the Remove, RemoveAt or RemoveRange methods on RelationshipCollection. They work the same as in a List\\ . Supported Databases Currently only Neo4J is supported. With the release of version 1.0 Azure Cosmos DB will also be supported. More info Docs Comming soon. Contribute & Bugs Grom is open source so feel free to checkout (pun intended) the repo to see the code, features being worked on and maybe even to create a PR yourself! We also have an issue board to have a nice overview of the issues we have and the ones being worked on. Bugs can be reported on the discussions page here .","title":"Grom"},{"location":"#grom","text":"Grom, a .NET graph database object relational mapper. Grom is an easy to use, low config ORM that lets you map your C# classes to nodes and relationships in various graph databases. This project is currently not production ready as it's still in beta. Version 1.0 is expected to release in Q4 2022. Since this project is open source and currently only worked on by the maintainer a 'beta' phase was needed in which a pre-production version is released so bugs can be found and fixed and important missing features can be requested before an actual production ready version is released. Feel free to try it out and if some feature is missing don't hesitate to open an issue!","title":"Grom"},{"location":"#quick-start","text":"","title":"Quick start"},{"location":"#connecting-grom-to-your-database","text":"Configuring Grom is easy, it only requires a database connection to be given to GromGraph.CreateConnection(...). You don't need to instantiate this class or call it anywhere after running CreateConnection once.","title":"Connecting Grom to your database"},{"location":"#neo4j","text":"To configure Grom for Neo4J simply use: GromGraph.CreateConnection(GraphDatabase.Driver(\"bolt://localhost:7687\", AuthTokens.Basic(\"neo4j\", \"test\"))); Any valid instance of Neo4J IDriver can be passed, so you are not restricted to username/password authentication.","title":"Neo4J"},{"location":"#mapping-a-class","text":"To map a class as a node you have to do two things: inherit from EntityNode and annotate each property you want to map with NodeProperty. Grom does also require an empty constructor for all nodes. A mapped class can be as simple as: public class Person : EntityNode { [NodeProperty] public string Name { get; set; } [NodeProperty] public int Age { get; set; } } Currently integer, boolean, string, float, long, DateTime and DateOnly are supported.","title":"Mapping a class"},{"location":"#persisting-a-node","text":"To persist a node simply call Persist() on any of your objects that inherit from EntityNode. var personNode = new Person(\"John\", 25); await personNode.Persist(); Grom is fully asynchronous so make sure you await when required.","title":"Persisting a node"},{"location":"#updating-a-node","text":"Updating a node is also done by calling Persist(). Grom will figure out if the node is allready created or not. var personNode = new Person(\"John\", 25); await personNode.Persist(); personNode.Age = 30; await personNode.Persist(); Do note that Grom only knows that a node exists if you have called Persist() on it or have retrieved it with Retrieve. It wont check if a node exists with the same properties in the database!","title":"Updating a node"},{"location":"#deleting-a-node","text":"A node can be deleted by calling DeleteNode(). await personNode.DeleteNode(); The actual object in your code will still exist but the node and all its relationships to other nodes will be deleted in the database.","title":"Deleting a node"},{"location":"#retrieving-a-node","text":"Nodes can be retrieved using Retrieve\\ . Nodes can be filtered by simply giving a lambda function that has a single parameter (the root node) and returns a boolean. Grom turns the lambda function into a query for you. var personNode = await Retrieve<Person> .Where(p => p.Name == \"John\") .GetSingle(); Boolean operators such as &&, ||, !, ==, !=, >, <, >= and <= are supported. Properties can be compared to constants, variables, method calls with no parameters and properties or fields in objects. Do note however that Grom can't turn everything a lambda can do into a query. Try to keep the lambda simple.","title":"Retrieving a node"},{"location":"#relationships","text":"For now only directed relationships are supported. Release 1.0 will also include support for undirected relationships. To define a relationship between nodes we first need to create a relationship entity. The entity needs to inherit from RelationshipBase and needs an empty constructor. Each property you want to map can be annotated with RelationshipProperty. A relationship entity will look something like this: public class Knows : RelationshipBase { [RelationshipProperty] public int ForYears { get; set; } public Knows() { } public Knows(int forYears) { ForYears = forYears; } } To define a relationship between nodes simply add a new property with type RelationshipCollection. This collection needs two arguments: a relationship type and a target node type. public class Person : EntityNode { [NodeProperty] public string Name { get; set; } [NodeProperty] public int Age { get; set; } public RelationshipCollection<Knows, Person> knownPeople { get; set; } = new(); public Person() { } public Person(string name, int age) { Name = name; Age = age; } } A relationship is added by adding an item to this collection: var person1 = new Person(\"John\", 25); var person2 = new Person(\"Doe\", 26); person1.knownPeople.Add(new Knows(5), person2); await person1.Persist(); Calling Persist() will, in adition to the node, also persist or update any descendant nodes and relationships. Updating works the same way as with nodes, change the property and call Persist() again on any ancestor node. To delete a relationship you can use the Remove, RemoveAt or RemoveRange methods on RelationshipCollection. They work the same as in a List\\ .","title":"Relationships"},{"location":"#supported-databases","text":"Currently only Neo4J is supported. With the release of version 1.0 Azure Cosmos DB will also be supported.","title":"Supported Databases"},{"location":"#more-info","text":"","title":"More info"},{"location":"#docs","text":"Comming soon.","title":"Docs"},{"location":"#contribute-bugs","text":"Grom is open source so feel free to checkout (pun intended) the repo to see the code, features being worked on and maybe even to create a PR yourself! We also have an issue board to have a nice overview of the issues we have and the ones being worked on. Bugs can be reported on the discussions page here .","title":"Contribute &amp; Bugs"},{"location":"contribute/","text":"Contributing to Grom Bugs Bugs can be reported on the Bug category of Groms GitHub discussions page . Please make sure to provide as much information and context as possible. If the problem is an unsolved bug then a contributor can make a new Issue for the projects board. The issue should have a link to the discussion, a description of the problem and if possible a preferred solution to the bug. The bug can be picked up by anyone and a PR for the fix can be created to the development branch. The fix should be released in the next release. Feature requests Features can be requested here . A contributor can then create a issue for anyone to pick up. Pull requests Anyone is free and encouraged to create a feature branch and implement something themselves. Whne you think the feature is done PR to develop can be created. The PR should describe briefly what the changes do and link to the relevant issue ticket. If there is no issue try to explain it in the PR description. We also expect integration tests to be added with every feature. Release process There is no set release cycle for now since the project is still small with only one contributor. A new release will be created when enough new features have been added or when there are bug fixes. To release first a release branch needs to be created from develop. When the branch has all the features and code needed for the release a PR can be created to main. This PR should trigger the release stage of the build pipeline. When the maintainer approves the release the new version will be added to NuGet.","title":"Contribute"},{"location":"contribute/#contributing-to-grom","text":"","title":"Contributing to Grom"},{"location":"contribute/#bugs","text":"Bugs can be reported on the Bug category of Groms GitHub discussions page . Please make sure to provide as much information and context as possible. If the problem is an unsolved bug then a contributor can make a new Issue for the projects board. The issue should have a link to the discussion, a description of the problem and if possible a preferred solution to the bug. The bug can be picked up by anyone and a PR for the fix can be created to the development branch. The fix should be released in the next release.","title":"Bugs"},{"location":"contribute/#feature-requests","text":"Features can be requested here . A contributor can then create a issue for anyone to pick up.","title":"Feature requests"},{"location":"contribute/#pull-requests","text":"Anyone is free and encouraged to create a feature branch and implement something themselves. Whne you think the feature is done PR to develop can be created. The PR should describe briefly what the changes do and link to the relevant issue ticket. If there is no issue try to explain it in the PR description. We also expect integration tests to be added with every feature.","title":"Pull requests"},{"location":"contribute/#release-process","text":"There is no set release cycle for now since the project is still small with only one contributor. A new release will be created when enough new features have been added or when there are bug fixes. To release first a release branch needs to be created from develop. When the branch has all the features and code needed for the release a PR can be created to main. This PR should trigger the release stage of the build pipeline. When the maintainer approves the release the new version will be added to NuGet.","title":"Release process"},{"location":"docs/","text":"Features Connecting Grom to your database Configuring Grom is easy, it only requires a database connection to be given to GromGraph.CreateConnection(...). You don't need to instantiate this class or call it anywhere after running CreateConnection once. Neo4J To configure Grom for Neo4J simply use: GromGraph.CreateConnection(GraphDatabase.Driver(\"bolt://localhost:7687\", AuthTokens.Basic(\"neo4j\", \"test\"))); Any valid instance of Neo4J IDriver can be passed, so you are not restricted to username/password authentication. Mapping a class To map a class as a node you have to do two things: inherit from EntityNode and annotate each property you want to map with NodeProperty. Grom does also require an empty constructor for all nodes. A mapped class can be as simple as: public class Person : EntityNode { [NodeProperty] public string Name { get; set; } [NodeProperty] public int Age { get; set; } } Currently integer, boolean, string, float, long, DateTime and DateOnly are supported. If a property can be null you can also specify this with the ? operator. Any other property without the NodeProperty attribute will be ignored by Grom. If you want a property to have a specific name in the database you can use the dbPropertyName parameter the NodeProperty attribute. public class Person : EntityNode { [NodeProperty(dbPropertyName: \"personName\")] public string Name { get; set; } [NodeProperty] public int Age { get; set; } } Persisting and updating a node To persist a node simply call Persist() on any of your objects that inherit from EntityNode. var personNode = new Person(\"John\", 25); await personNode.Persist(); Persist() will also check if the object has relationships and recursively create the relationships and related nodes. Updating a node is also done by calling Persist(). As with persisting all related nodes and relationships will also be updated. Grom will figure out if the node is allready created or not. var personNode = new Person(\"John\", 25); await personNode.Persist(); personNode.Age = 30; await personNode.Persist(); To keep in mind: Grom only knows that a node exists if you have called Persist() on it or have retrieved it with Retrieve. It wont check if a node exists with the same properties in the database! The entire node is updated with Persist() i.e. all the properties are overwritten. If you want to only persist or update the root node and are sure nothing else is changed than you can use Persist() with the Degree parameter. var personNode = new Person(\"John\", 25); await personNode.Persist(Degree: 0); You can set Degree to any number of 'jumps' you want to update from the root node. Degree 1 means persisting the root node and its directly related nodes and relationships, Degree 2 their own directly related nodes and relationships, etc. ------------------------ Degree: 2 node4 node5 | | relationship3 relationship4 | | ------------------------ Degree: 1 node2 node3 | | relationship1 relationship2 \\ / ------------------------ Degree: 0 node1 Deleting a node A node can be deleted by calling DeleteNode(). await personNode.DeleteNode(); The actual object in your code will still exist but the node and all its relationships to other nodes will be deleted in the database. Retrieving a node Nodes can be retrieved using Retrieve\\ . Nodes can be filtered by simply giving a lambda function that has a single parameter (the root node) and returns a boolean. Grom turns the lambda function into a query for you. var personNode = await Retrieve<Person> .Where(p => p.Name == \"John\") .GetSingle(); Boolean operators such as &&, ||, !, ==, !=, >, <, >= and <= are supported. Properties can be compared to constants, variables, method calls with no parameters and properties or fields in objects. Do note however that Grom can't turn everything a lambda can do into a query. Try to keep the lambda simple. If you do not want to retrieve a node with all its relationships .IgnoreRelatedNodes() can be added to the Retrieve query. Relationships For now only directed relationships are supported. Release 1.0 will also include support for undirected relationships. To define a relationship between nodes we first need to create a relationship entity. The entity needs to inherit from RelationshipBase and needs an empty constructor. Each property you want to map can be annotated with RelationshipProperty. A relationship entity will look something like this: public class Knows : RelationshipBase { [RelationshipProperty] public int ForYears { get; set; } public Knows() { } public Knows(int forYears) { ForYears = forYears; } } RelationshipProperty also supports a dbPropertyName parameter to specify a name for the property in the database. To define a relationship between nodes simply add a new property with type RelationshipCollection. This collection needs two arguments: a relationship type and a target node type. public class Person : EntityNode { [NodeProperty] public string Name { get; set; } [NodeProperty] public int Age { get; set; } public RelationshipCollection<Knows, Person> knownPeople { get; set; } = new(); public Person() { } public Person(string name, int age) { Name = name; Age = age; } } A relationship is added by adding an item to this collection: var person1 = new Person(\"John\", 25); var person2 = new Person(\"Doe\", 26); person1.knownPeople.Add(new Knows(5), person2); await person1.Persist(); Calling Persist() will, in adition to the node, also persist or update any descendant nodes and relationships. Updating works the same way as with nodes, change the property and call Persist() again on any ancestor node. If you are sure that you only changed properties in one relationship you can use UpdateRelationshipOnly(). This will make sure that only the relationship is updated on which UpdateRelationshipOnly() is called. var person1 = new Person(\"John\", 25); var person2 = new Person(\"Doe\", 26); person1.knownPeople.Add(new Knows(5), person2); await person1.Persist(); person1.knownPeople.First().Relationship.ForYears = 10; await person1.knownPeople.First().Relationship.UpdateRelationshipOnly(); UpdateRelationshipOnly() does not work on relationships that are not persisted yet. To delete a relationship you can use the Remove, RemoveAt or RemoveRange methods on RelationshipCollection. They work the same as in a List\\ . About Grom How Grom works Grom works, as any ORM, by mapping C# concepts to concepts in graph databases. A class become a node, a class property becomes a node property and a property that is a list of another class becomes a relationship. Grom links objects to nodes with the internal property EntityNodeId in EntityNode. This way Grom knows if the object already exists in the database or not and thus if a node needs to be created or updated. The rest of Grom is simply an exercise of translating C# and .NET to the right database in a good way. Philosophy of Grom The idea of Grom is to leverage as many C# and .NET features as possible to create a simple, modern, reliable and feature rich ORM for graph databases. Other graph database ORMs use a fluent API where you can define a node and its properties. This makes the ORM much simpler and lighter but you also lose a lot of the benefits that C# and .NET have. For example Grom gives you inheritance out of the box even though this is not a concept in most graph databases. Querying nodes is also simply done by writing a lambda expression instead of having to learn an intermediate language specific to the ORM. Another important concept of Grom is to map C# to graph databases not graph databases to C#. This means that we don't translate all features of graph databases to C# but see whats usefull in C# and try to make that work in graph databases.","title":"Docs"},{"location":"docs/#features","text":"","title":"Features"},{"location":"docs/#connecting-grom-to-your-database","text":"Configuring Grom is easy, it only requires a database connection to be given to GromGraph.CreateConnection(...). You don't need to instantiate this class or call it anywhere after running CreateConnection once.","title":"Connecting Grom to your database"},{"location":"docs/#neo4j","text":"To configure Grom for Neo4J simply use: GromGraph.CreateConnection(GraphDatabase.Driver(\"bolt://localhost:7687\", AuthTokens.Basic(\"neo4j\", \"test\"))); Any valid instance of Neo4J IDriver can be passed, so you are not restricted to username/password authentication.","title":"Neo4J"},{"location":"docs/#mapping-a-class","text":"To map a class as a node you have to do two things: inherit from EntityNode and annotate each property you want to map with NodeProperty. Grom does also require an empty constructor for all nodes. A mapped class can be as simple as: public class Person : EntityNode { [NodeProperty] public string Name { get; set; } [NodeProperty] public int Age { get; set; } } Currently integer, boolean, string, float, long, DateTime and DateOnly are supported. If a property can be null you can also specify this with the ? operator. Any other property without the NodeProperty attribute will be ignored by Grom. If you want a property to have a specific name in the database you can use the dbPropertyName parameter the NodeProperty attribute. public class Person : EntityNode { [NodeProperty(dbPropertyName: \"personName\")] public string Name { get; set; } [NodeProperty] public int Age { get; set; } }","title":"Mapping a class"},{"location":"docs/#persisting-and-updating-a-node","text":"To persist a node simply call Persist() on any of your objects that inherit from EntityNode. var personNode = new Person(\"John\", 25); await personNode.Persist(); Persist() will also check if the object has relationships and recursively create the relationships and related nodes. Updating a node is also done by calling Persist(). As with persisting all related nodes and relationships will also be updated. Grom will figure out if the node is allready created or not. var personNode = new Person(\"John\", 25); await personNode.Persist(); personNode.Age = 30; await personNode.Persist(); To keep in mind: Grom only knows that a node exists if you have called Persist() on it or have retrieved it with Retrieve. It wont check if a node exists with the same properties in the database! The entire node is updated with Persist() i.e. all the properties are overwritten. If you want to only persist or update the root node and are sure nothing else is changed than you can use Persist() with the Degree parameter. var personNode = new Person(\"John\", 25); await personNode.Persist(Degree: 0); You can set Degree to any number of 'jumps' you want to update from the root node. Degree 1 means persisting the root node and its directly related nodes and relationships, Degree 2 their own directly related nodes and relationships, etc. ------------------------ Degree: 2 node4 node5 | | relationship3 relationship4 | | ------------------------ Degree: 1 node2 node3 | | relationship1 relationship2 \\ / ------------------------ Degree: 0 node1","title":"Persisting and updating a node"},{"location":"docs/#deleting-a-node","text":"A node can be deleted by calling DeleteNode(). await personNode.DeleteNode(); The actual object in your code will still exist but the node and all its relationships to other nodes will be deleted in the database.","title":"Deleting a node"},{"location":"docs/#retrieving-a-node","text":"Nodes can be retrieved using Retrieve\\ . Nodes can be filtered by simply giving a lambda function that has a single parameter (the root node) and returns a boolean. Grom turns the lambda function into a query for you. var personNode = await Retrieve<Person> .Where(p => p.Name == \"John\") .GetSingle(); Boolean operators such as &&, ||, !, ==, !=, >, <, >= and <= are supported. Properties can be compared to constants, variables, method calls with no parameters and properties or fields in objects. Do note however that Grom can't turn everything a lambda can do into a query. Try to keep the lambda simple. If you do not want to retrieve a node with all its relationships .IgnoreRelatedNodes() can be added to the Retrieve query.","title":"Retrieving a node"},{"location":"docs/#relationships","text":"For now only directed relationships are supported. Release 1.0 will also include support for undirected relationships. To define a relationship between nodes we first need to create a relationship entity. The entity needs to inherit from RelationshipBase and needs an empty constructor. Each property you want to map can be annotated with RelationshipProperty. A relationship entity will look something like this: public class Knows : RelationshipBase { [RelationshipProperty] public int ForYears { get; set; } public Knows() { } public Knows(int forYears) { ForYears = forYears; } } RelationshipProperty also supports a dbPropertyName parameter to specify a name for the property in the database. To define a relationship between nodes simply add a new property with type RelationshipCollection. This collection needs two arguments: a relationship type and a target node type. public class Person : EntityNode { [NodeProperty] public string Name { get; set; } [NodeProperty] public int Age { get; set; } public RelationshipCollection<Knows, Person> knownPeople { get; set; } = new(); public Person() { } public Person(string name, int age) { Name = name; Age = age; } } A relationship is added by adding an item to this collection: var person1 = new Person(\"John\", 25); var person2 = new Person(\"Doe\", 26); person1.knownPeople.Add(new Knows(5), person2); await person1.Persist(); Calling Persist() will, in adition to the node, also persist or update any descendant nodes and relationships. Updating works the same way as with nodes, change the property and call Persist() again on any ancestor node. If you are sure that you only changed properties in one relationship you can use UpdateRelationshipOnly(). This will make sure that only the relationship is updated on which UpdateRelationshipOnly() is called. var person1 = new Person(\"John\", 25); var person2 = new Person(\"Doe\", 26); person1.knownPeople.Add(new Knows(5), person2); await person1.Persist(); person1.knownPeople.First().Relationship.ForYears = 10; await person1.knownPeople.First().Relationship.UpdateRelationshipOnly(); UpdateRelationshipOnly() does not work on relationships that are not persisted yet. To delete a relationship you can use the Remove, RemoveAt or RemoveRange methods on RelationshipCollection. They work the same as in a List\\ .","title":"Relationships"},{"location":"docs/#about-grom","text":"","title":"About Grom"},{"location":"docs/#how-grom-works","text":"Grom works, as any ORM, by mapping C# concepts to concepts in graph databases. A class become a node, a class property becomes a node property and a property that is a list of another class becomes a relationship. Grom links objects to nodes with the internal property EntityNodeId in EntityNode. This way Grom knows if the object already exists in the database or not and thus if a node needs to be created or updated. The rest of Grom is simply an exercise of translating C# and .NET to the right database in a good way.","title":"How Grom works"},{"location":"docs/#philosophy-of-grom","text":"The idea of Grom is to leverage as many C# and .NET features as possible to create a simple, modern, reliable and feature rich ORM for graph databases. Other graph database ORMs use a fluent API where you can define a node and its properties. This makes the ORM much simpler and lighter but you also lose a lot of the benefits that C# and .NET have. For example Grom gives you inheritance out of the box even though this is not a concept in most graph databases. Querying nodes is also simply done by writing a lambda expression instead of having to learn an intermediate language specific to the ORM. Another important concept of Grom is to map C# to graph databases not graph databases to C#. This means that we don't translate all features of graph databases to C# but see whats usefull in C# and try to make that work in graph databases.","title":"Philosophy of Grom"}]}